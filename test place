#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cctype>

enum TokenType { //----- add token type to handle commas
    ID, NUMBER, ASSIGN, PLUS, SEMICOLON,
    INT, FLOAT, LPAREN, RPAREN, LBRACE, RBRACE,
    INVALID, END_OF_FILE
};

struct Token {
    TokenType type;
    std::string lexeme;
};

class Lexer {
public:
    Lexer(const std::string &input) : input(input), pos(0) {}

    Token getNextToken() {
        while (pos < input.size() && isspace(input[pos])) pos++; // Skip whitespace
        if (pos >= input.size()) return {END_OF_FILE, ""};

        char currentChar = input[pos];
        if (isalpha(currentChar) || currentChar == '_') return identifier();
        if (isdigit(currentChar)) return number();
        if (currentChar == '=') { pos++; return {ASSIGN, "="}; }
        if (currentChar == '+') { pos++; return {PLUS, "+"}; }
        if (currentChar == ';') { pos++; return {SEMICOLON, ";"}; }
        if (input.substr(pos, 3) == "int") { pos += 3; return {INT, "int"}; }
        if (input.substr(pos, 5) == "float") { pos += 5; return {FLOAT, "float"}; }
        if (currentChar == '(') { pos++; return {LPAREN, "("}; }
        if (currentChar == ')') { pos++; return {RPAREN, ")"}; }
        if (currentChar == '{') { pos++; return {LBRACE, "{"}; }
        if (currentChar == '}') { pos++; return {RBRACE, "}"}; }

        pos++;
        return {INVALID, std::string(1, currentChar)};
    }

private:
    std::string input;
    size_t pos;

    Token identifier() {
        size_t start = pos;
        while (pos < input.size() && (isalnum(input[pos]) || input[pos] == '_')) pos++;
        return {ID, input.substr(start, pos - start)};
    }

    Token number() {
        size_t start = pos;
        while (pos < input.size() && isdigit(input[pos])) pos++;
        return {NUMBER, input.substr(start, pos - start)};
    }
};

class Parser {
public:
    Parser(Lexer &lexer) : lexer(lexer), currentToken(lexer.getNextToken()) {}

    void parse() {
        while (currentToken.type != END_OF_FILE) {
            if (currentToken.type == INT || currentToken.type == FLOAT) {
                function(); // Parse function definitions
            } else {
                error("Unexpected token at top level");
                currentToken = lexer.getNextToken(); // Skip the token
            }
        }
        std::cout << "The program is generated by the grammar\n";
    }

private:
    Lexer &lexer;
    Token currentToken;

    void function() {
        std::cout << "Function parsing started. Current token: " << currentToken.lexeme << " (Type: " << tokenTypeToString(currentToken.type) << ")\n";

        if (currentToken.type == INT || currentToken.type == FLOAT) {
            TokenType returnType = currentToken.type; // Store return type
            std::cout << "Detected return type: " << tokenTypeToString(returnType) << "\n";
            currentToken = lexer.getNextToken();  // Consume return type

            // Expect a function name
            if (currentToken.type == ID) {
                std::cout << "Function name: " << currentToken.lexeme << "\n";
                currentToken = lexer.getNextToken();  // Consume function name

                // Expect '('
                if (currentToken.type == LPAREN) {
                    currentToken = lexer.getNextToken();  // Consume '('
                    std::cout << "Parameters start...\n";
                    params();  // Parse parameter list

                    // Expect ')'
                    if (currentToken.type == RPAREN) {
                        currentToken = lexer.getNextToken();  // Consume ')'
                        std::cout << "Parameters end...\n";

                        // Expect '{'
                        if (currentToken.type == LBRACE) {
                            currentToken = lexer.getNextToken();  // Consume '{'
                            stmt_list();  // Parse the function body (list of statements)

                            // Expect '}'
                            if (currentToken.type == RBRACE) {
                                currentToken = lexer.getNextToken();  // Consume '}'
                                std::cout << "Function parsing completed.\n";
                            } else {
                                error("Expected '}'");
                            }
                        } else {
                            error("Expected '{'");
                        }
                    } else {
                        error("Expected ')'");
                    }
                } else {
                    error("Expected '('");
                }
            } else {
                error("Expected function name");
            }
        } else {
            error("Expected return type");
        }
    }

    void params() {
        // Parse parameters, expecting "type identifier" pairs
        while (true) {
            if (currentToken.type == INT || currentToken.type == FLOAT) {
                currentToken = lexer.getNextToken(); // Consume type
                if (currentToken.type == ID) {
                    std::cout << "Parameter: " << currentToken.lexeme << " (Type: " << tokenTypeToString(currentToken.type) << ")\n";
                    currentToken = lexer.getNextToken(); // Consume identifier
                } else {
                    error("Expected parameter name");
                }
            } else {
                break; // Exit if no more types
            }

            // Check for a comma to continue to the next parameter
            if (currentToken.type == ',') {
                currentToken = lexer.getNextToken(); // Consume comma
            } else {
                break; // Exit if no more parameters
            }
        }
    }

    void stmt_list() {
        while (currentToken.type != RBRACE && currentToken.type != END_OF_FILE) {
            stmt();  // Process individual statements
            if (currentToken.type == SEMICOLON) {
                currentToken = lexer.getNextToken();  // Consume ';'
            } else {
                error("Expected ';'");
            }
        }
    }

    void stmt() {
        if (currentToken.type == ID) {
            currentToken = lexer.getNextToken();  // Consume ID
            if (currentToken.type == ASSIGN) {
                currentToken = lexer.getNextToken();  // Consume '='
                expr();  // Parse expression
            } else {
                error("Expected '='");
            }
        } else {
            error("Expected identifier");
        }
    }

    void expr() {
        if (currentToken.type == ID || currentToken.type == NUMBER) {
            currentToken = lexer.getNextToken();  // Consume identifier or number
        } else {
            error("Expected identifier or number");
        }
    }
/* ------- code gets messed up at this error function somewhere along the lines it gets called wrong time
 * code still outputs right token type and everything but just as an error message and not output
 * suggestion: just act like its not an error and just have it be "output" or rewrite error function
 *  also don't fg to change file to yours ----end 
 */
    void error(const std::string &message) {
        std::cerr << "Syntax Error: " << message
                  << ", found " << currentToken.lexeme << " (Type: " << tokenTypeToString(currentToken.type) << ")\n";
    }

    std::string tokenTypeToString(TokenType type) { // added this to switch to sring
        switch (type) {
            case ID: return "ID";
            case NUMBER: return "NUMBER";
            case ASSIGN: return "ASSIGN";
            case PLUS: return "PLUS";
            case SEMICOLON: return "SEMICOLON";
            case INT: return "INT";
            case FLOAT: return "FLOAT";
            case LPAREN: return "LPAREN";
            case RPAREN: return "RPAREN";
            case LBRACE: return "LBRACE";
            case RBRACE: return "RBRACE";
            case INVALID: return "INVALID";
            case END_OF_FILE: return "END_OF_FILE";
            default: return "UNKNOWN";
        }
    }
};

int main() {
    std::ifstream inputFile("/Users/jadenocampo/Desktop/parser_project/Parser-Project/TestProgram2.txt");
    if (!inputFile.is_open()) {
        std::cerr << "Error opening file\n";
        return 1;
    }

    std::string inputProgram;
    std::string line;
    while (getline(inputFile, line)) {
        inputProgram += line + "\n";
    }
    inputFile.close();

    Lexer lexer(inputProgram);
    Parser parser(lexer);
    parser.parse();

    return 0;
}
