#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cctype>

enum TokenType {
    ID, NUMBER, ASSIGN, PLUS, SEMICOLON,
    INT, FLOAT, LPAREN, RPAREN, LBRACE, RBRACE,
    INVALID, END_OF_FILE
};

struct Token {
    TokenType type;
    std::string lexeme;
};

class Lexer {
public:
    Lexer(const std::string &input) : input(input), pos(0) {}

    Token getNextToken() {
        while (pos < input.size() && isspace(input[pos])) pos++; // Skip whitespace
        if (pos >= input.size()) return {END_OF_FILE, ""};

        char currentChar = input[pos];
        if (isalpha(currentChar) || currentChar == '_') return identifier();
        if (isdigit(currentChar)) return number();
        if (currentChar == '=') { pos++; return {ASSIGN, "="}; }
        if (currentChar == '+') { pos++; return {PLUS, "+"}; }
        if (currentChar == ';') { pos++; return {SEMICOLON, ";"}; }
        if (input.substr(pos, 3) == "int") { pos += 3; return {INT, "int"}; }
        if (input.substr(pos, 5) == "float") { pos += 5; return {FLOAT, "float"}; }
        if (currentChar == '(') { pos++; return {LPAREN, "("}; }
        if (currentChar == ')') { pos++; return {RPAREN, ")"}; }
        if (currentChar == '{') { pos++; return {LBRACE, "{"}; }
        if (currentChar == '}') { pos++; return {RBRACE, "}"}; }

        pos++;
        return {INVALID, std::string(1, currentChar)};
    }

private:
    std::string input;
    size_t pos;

    Token identifier() {
        size_t start = pos;
        while (pos < input.size() && (isalnum(input[pos]) || input[pos] == '_')) pos++;
        return {ID, input.substr(start, pos - start)};
    }

    Token number() {
        size_t start = pos;
        while (pos < input.size() && isdigit(input[pos])) pos++;
        return {NUMBER, input.substr(start, pos - start)};
    }
};

class Parser {
public:
    Parser(Lexer &lexer) : lexer(lexer), currentToken(lexer.getNextToken()) {}

    void parse() {
        while (currentToken.type != END_OF_FILE) {
            if (currentToken.type == INT || currentToken.type == FLOAT) {
                function(); // Parse function definitions
            } else if (currentToken.type == ID) {
                stmt(); // Handle statements if it's not a function declaration
            } else {
                error("Unexpected token");
                currentToken = lexer.getNextToken(); // Skip the token
            }
        }
        std::cout << "The program is generated by the grammar\n";
    }


private:
    Lexer &lexer;
    Token currentToken;

    void function() {
    std::cout << "Function parsing started. Current token: " << currentToken.lexeme << "\n";

    if (currentToken.type == INT || currentToken.type == FLOAT) {
        TokenType returnType = currentToken.type; // Store return type
        std::cout << "Detected return type: " << returnType << "\n";
        currentToken = lexer.getNextToken();  // Consume return type

        // Expect a function name
        if (currentToken.type == ID) {
            std::cout << "Function name: " << currentToken.lexeme << "\n";
            currentToken = lexer.getNextToken();  // Consume function name

            // Expect '('
            if (currentToken.type == LPAREN) {
                currentToken = lexer.getNextToken();  // Consume '('
                std::cout << "Parameters start...\n";
                params();  // Parse parameter list

                // Expect ')'
                if (currentToken.type == RPAREN) {
                    currentToken = lexer.getNextToken();  // Consume ')'
                    std::cout << "Parameters end...\n";

                    // Expect '{'
                    if (currentToken.type == LBRACE) {
                        currentToken = lexer.getNextToken();  // Consume '{'
                        stmt_list();  // Parse the function body (list of statements)

                        // Expect '}'
                        if (currentToken.type == RBRACE) {
                            currentToken = lexer.getNextToken();  // Consume '}'
                            std::cout << "Function parsing completed.\n";
                        } else {
                            error("Expected '}'");
                        }
                    } else {
                        error("Expected '{'");
                    }
                } else {
                    error("Expected ')'");
                }
            } else {
                error("Expected '('");
            }
        } else {
            error("Expected function name");
        }
    } else {
        error("Expected return type");
    }
}


    void params() {
        // Example implementation to parse parameters
        while (currentToken.type == ID) { // Assuming ID represents parameter type
            currentToken = lexer.getNextToken();  // Consume parameter type
            if (currentToken.type == ',') {
                currentToken = lexer.getNextToken();  // Skip comma
            } else {
                break; // Exit on reaching the end of parameters
            }
        }
    }

    void stmt_list() {
        while (currentToken.type == ID) {
            stmt();  // Process individual statements
            if (currentToken.type == SEMICOLON) {
                currentToken = lexer.getNextToken();  // Consume ';'
            } else {
                error("Expected ';'");
            }
        }
    }

    void stmt() {
        if (currentToken.type == ID) {
            currentToken = lexer.getNextToken();  // Consume ID
            if (currentToken.type == ASSIGN) {
                currentToken = lexer.getNextToken();  // Consume '='
                expr();  // Parse expression
            } else {
                error("Expected '='");
            }
        } else {
            error("Expected identifier");
        }
    }

    void expr() {
        if (currentToken.type == ID || currentToken.type == NUMBER) {
            currentToken = lexer.getNextToken();  // Consume identifier or number
        } else {
            error("Expected identifier or number");
        }
    }

    void error(const std::string &message) {
        std::cerr << "Syntax Error: " << message
                  << ", found " << currentToken.lexeme << " (Type: " << currentToken.type << ")\n";
    }
};

int main() {
    std::ifstream inputFile("/Users/jadenocampo/Desktop/parser_project/Parser-Project/TestProgram2.txt");
    if (!inputFile.is_open()) {
        std::cerr << "Error opening file\n";
        return 1;
    }

    std::string inputProgram;
    std::string line;
    while (getline(inputFile, line)) {
        inputProgram += line + "\n";
    }
    inputFile.close();

    Lexer lexer(inputProgram);
    Parser parser(lexer);
    parser.parse();

    return 0;
}

